<h1>IA</h1>
<h2>TP1</h2>
<p> Dans le dossier <strong>TP1</strong>, pour exécuter l'algorithme <em>A*</em> sur la situation initiale : <br>
<em>initial_state([ [b, h, c],       % C EST L EXEMPLE PRIS EN COURS <br>
                    [a, f, d],       % <br>
                    [g,vide,e] ]).   % h1=4,   h2=5,   f*=5 </em> <br>
Il suffit d'exécuter les commandes : <br>
<strong>
[astar]. <br>
main. <br>
</strong> </p>
<h2>TP2</h2>
<p>
Dans le dossier <strong>TP2</strong>, pour exécuter l'algorithme <em>negamax</em> sur une situation initiale du morpion = matrice vide, exécuter les commandes : <br>
<strong>
[negamax]. <br>
main(?C,?V,+Pmax).</strong>  <em>(Pmax doit être fourni en entrée, avec 1<=Pmax<=9 dans le cas du morpion / tictactoe)</em> <br> </p>
<h3>alphabeta</h3>
<p> Le document <em>alphabeta.pl</em> est une ébauche de code pour l'algorithme alphabeta <em>(suite de negamax) (cf. compte-rendu)</em>. </p>
<h2>CR_Guittard_Kanane</h2>
<p>
Le compte-rendu se suffit à lui-même. Il reprend : <br>
<ul>
<li> Des requêtes intéressantes à comprendre </li>
<li> L'ensemble du code, bloc par bloc </li>
<li> Des tests unitaires pour la quasi-totalité des prédicats développés </li>
<li> Des ouvertures, des commentaires et des améliorations entrevues / essayées </li>
</ul>
</p>
